

# 核心要义：

1. 其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。
2. 深度优先搜索的思想是***<u>沿着一个方向搜到底，如果行不通，则返回来试其他的路径。</u>***

# 引例：

《Aha! Algorithms》第四章第一节，输入n,输出n的全排列。

理解：

1. 可以把这个问题形象化即往９个空盒子中放９张扑克牌。

2. 最基本的也是==最==关键的问题：如何往小盒子里放扑克牌？==每个小盒子中都可能放1,2,3号扑克牌，这需要一一尝试，用for循环来解决==--对应下面代码２１　２２行

   ```c++
   #include <cstdio>
   #define max_n 10
   int n;
   int permutation[max_n + 5], keep[max_n + 5];
   void dfs(int step);                     //语义信息：step表示站在第step个盒子面前
   
   int main() {
       scanf("%d", &n);
       dfs(1);                                       //首先站在1号盒子面前
       return 0;
   }
   
   void dfs(int step) {
       if (step == n + 1) {　　　　//表示前n位已经放好扑克牌
           for (int i = 1; i <= n; i++)
               printf("%d", permutation[i]);
           printf("\n");
           return;                                    //返回之前的一步（最近一次调用dfs函数的地方）
       }
       
       //此时站在第step个盒子面前应该放哪张牌呢？？
       //按照1 2 3...n的顺序一一尝试
       for (int i = 1; i <=  n ; i++) {
           if (keep[i]) continue;
           //第一个未被标记的ｉ可以放在第step个盒子中
           permutation[step] = i;
           keep[i] = 1;
           //接下来的代码为整段代码的核心中的核心！！！！必须写在for循环里面！！！
           //第step个盒子已经放好牌，接下来需要走到下一个盒子面前
           dfs(step + 1);  //通过递归程序来实现
           keep[i] = 0;//非常非常重要！！！！因为程序进行到这一行一定是下一步已经return回来了，这意味着当前第step个盒子中的数应该往下走！        
       }
       return ;
   }
   ```

   

3. Conclusion：

   + 这个简单的例子，核心代码不超过２０行，却饱含ＤＦＳ的基本模型。

   + 理解DFS的关键在于解决==“当下该如何做”==，至于==“下一步如何做”==，则与“当下该如何做”是==一样==的！！！！

   + 比如我们这里写的dfs函数的主要功能就是解决当==第step个盒子面前的时候你该怎么办==（这是这个递归函数的语义信息），通常的方法就是把每一种可能都去尝试一遍（一般用for循环去遍历）。当前这一步解决后便进入下一步dfs(step + 1)。而下一步的解决方案和当前这步的解决方案是完全一样的。

   + 下面的代码就是DFS的基本模型：

     ```c
     void dfs(int step) {
         判断边界
         尝试每一种可能 for (int i = 1; i <= n; i++) {
             继续下一步 dfs(step + 1);
         }
         return;
     }
     ```

   + 每一种尝试都是一种“扩展”，==每次站在一个盒子面前的时候，其实都有n种扩展方法（迷宫问题则是上下左右四种扩展方法），　但是并不是每种扩展都能够扩展成功==，所以撞到南墙是要回头的。

4. 变形：《Aha!Algorithms》中４．１．２个例子也就是３．１中的例题就：坑爹的奥数　的本质就是从全排列中找出符合条件的数即可，这种==抽象==能力十分重要！！！

5. 光哥的conclusion：

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6ly1gjcg6menu0j30u00v2qj4.jpg)

   + 在这个例子中，哪些盒子里被填了数，哪些没有，这就是==状态==，而在前面`depth-1`个数已填好的情况下，填第`depth`个数，这就是==状态转移==。

6. ***<u>我个人的conclusion</u>***：

   + 先按光哥说的，想好==状态==和==状态转移==。(ps:状态`!=`dfs函数的语义信息)
   + 再按《啊哈！算法》中说的，利用那个dfs基本模型去写代码。

# 优化--剪枝

1. 有些情况下不可能对所有可能的情况都进行搜索，所以必须根据条件进行优化，省去一些非必要的搜索，即==剪枝==。

2. 例子--求解组合问题

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6ly1gjcgf0efrbj30ub0u0wr9.jpg)

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6ly1gjcgf6c4dkj31e20tsguu.jpg)

   + 代码见`2.组合数.cpp`





# 1.走迷宫系列问题

## 1.1初级迷宫问题

《Aha! Algorithms》4.2解救小哈

理解:

1. 最开始在起点的时候只能往右走或者往下走，但是到底该往哪儿走呢？此时要是能有两个小哼就好了，一个往右走，一个往下走。

2. 但是现在只有一个小哼，所以只能==一个一个地去尝试==。我们可以==先让小哼往右边走，直到走不通的时候再回到这里，再去尝试另一个方向。==我们这里规定一个顺序，按顺时针方向来尝试（即右、下、左、上）

3. 请注意如果到了终点并不是意味着就结束了，因为刚才很多地方在选择方向的时候都有多种选择，因此我们需要返回到这些地方继续尝试往别的方向走，直到把所有可能都尝试一遍，最后输出最短的一条路径。

   

方案：

1. ***<u>状态</u>***就是在哪个位置，***<u>状态转移</u>***就是下一步该走到哪。
2. 我们尝试来解决，dfs()函数的功能是==解决当前应该怎么办==。
3. 而小哼在某个点的时候需要处理的是：==先检查小哼是否已经到终点，如果没有到达则找出下一步可以走的方向==，为了解决这个问题，dfs函数只需要==维护三个参数==，即x, y坐标和==当前已经走过的步数step==。

```C++
#include <iostream>
#include <cstdio>
#include <cinttypes>
#define max_n 50
using namespace std;

int map[max_n + 5][max_n + 5], keep[max_n + 5][max_n + 5];
int n, m, sx, sy, p, q;
int min_steps = INT32_MAX;
int dnext[4][2] = {
    {0, 1}, {1, 0},
    {0, -1}, {-1, 0}
};                                                             //方向数组
void dfs(int x, int y, int step);    //语义信息就是第二点所提到的

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            cin >> map[i][j];
    }
    cin >> sx >> sy >> p >> q;
    keep[sx][sy] = 1;
    dfs(sx, sy, 0);
    printf("最短的路径是%d步\n", min_steps);
    return 0;
}

void dfs(int x, int y, int step) {
    //　设置出口，如果到达终点
    if (x == p && y == q) {
        if (step < min_steps) min_steps = step;
        return;
    }
    //如果没有到达终点，则利用for循环遍历下一次要走的每种情况
    for (int i = 0; i < 4; i++) {
        int dx = x + dnext[i][0];
        int dy = y + dnext[i][1];
        if (dx < 0 || dx >= n || dy < 0 || dy >= m) continue;
        if (map[dx][dy] == 1 || keep[dx][dy] == 1) continue;  //这两行是剪枝的过程
        keep[dx][dy] = 1;
        dfs(dx, dy, step + 1);
        keep[dx][dy] = 0;                                    //回溯时一定要记得解锁！！！！
    }
    return ;
}
```

4. 测试样例：

   5 4
   0 0 1 0
   0 0 0 0
   0 0 1 0
   0 1 0 0
   0 0 0 1
   0 0 3 2

   应输出结果：7

PS:==有些题目dfs()函数里回溯的时候不需要解锁，==比如4.4炸弹人和计蒜客的“红与黑”，得看==具体题目的语义信息==！！！

