参考资料：

https://time.geekbang.org/column/article/270342



# 1.前言

1. 快速排序是一种优秀的排序算法，这一点毫无疑问，可并不代表这种排序算法就是无敌的，它也有自己的问题。
2. 所以在工程实现中，我们往往使用的都是混合排序算法，例如STL中的sort，使用的就是“**快速排序+插入排序+堆排序**”的方式。
3. 因此，面对算法学习，永远不要功利心太重，因为你永远不会知道，你抛弃掉的是什么样的伟大思想。



# 2.算法思想

1. 基础的快排算法思想很简单，核心就是一句话：**找到每个基准值该在的位置**

2. 算法步骤（三步走）：

   1. 选择一个值作为**基准值**
   2. **Partition**（即将小于基准值的元素放在基准值前面，大于基准值的元素放在基准值的后面）
   3. **对基准值左右两侧，递归**地进行第一步和第二步

3. 详解三步走

   + 选择一个值作为基准值

     最简单的方法，就是选择区间的头部元素作为基准值

     ![img](https://wx2.sinaimg.cn/mw690/005LasY6ly1govaf9kyr9j30iz08xdgw.jpg)

   + Partition（分割）

     + 简单来说，就是空出一个位置，反复地前后调换元素（当选择了基准值之后，其位置就相当于被空出来了）
     + 其本质就是==找到基准值该在的位置==

     

     ![img](https://wx4.sinaimg.cn/mw690/005LasY6ly1govaie4plkj30ib095my5.jpg)

     ![img](https://wx4.sinaimg.cn/mw690/005LasY6ly1govaiovwrlj30jo0aeacj.jpg)

   + 对基准值的左右两侧，递归地进行第一步和第二步

     这个没什么好说的啦



# 3.复杂度分析

## 3.1时间复杂度

1. 我们使用一种叫做**二叉树分析法**的方法

2. 设$T(n)$为对n个元素的数组进行快排所用的时间

3. 首先，不难理解，单次partition操作的时间复杂度为$O(n)$

4. 可以得到，$T(n) = n + T(L) + T(R) $

   其中，n是单次partition操作的用时，L和R分别代表**左右区间中元素的数量**

   ![img](https://wx3.sinaimg.cn/mw690/005LasY6ly1govaxkkh29j30iy09tjsu.jpg)



接下来就到了**二叉树分析法**了

1. 我们借助二叉树的结构来求$T(n)$。

   如下图所示：

   ![img](https://wx3.sinaimg.cn/mw690/005LasY6ly1govd6bf5rrj30jo0a30ux.jpg)

2. 首先，我们可以将基准值看成是n个元素组成的二叉树的根节点，那么partition操作就是找到这个根节点的正确位置，总用时就是n

3. 由二叉树的递归定义可知，找到左子树根节点的用时就是L，找到右子树根节点的用时就是R。这样，我们就得到了第二层上所有节点的用时：L + R = n - 1。**我们可以将这个值大致看成是n**

4. 运用此方法，我们可以得到每层的总用时

   | 层数 | 总用时            |
   | ---- | ----------------- |
   | 1    | n                 |
   | 2    | n - 1             |
   | 3    | n - 3             |
   | 4    | n - 7             |
   | k    | n - (2^(k-1) - 1) |

5. 其实，如果n足够大，那么每一层上的所有节点的总用时就都**约等于n**

   ==存疑，为啥可以约等于？层数越深，不就越不能约等于吗？==

6. 那么，快排的总用时，就可以约等于$n \times h(tree)$，因此，快排的执行效率是和树高有关系的

7. 对于有n个节点的二叉树，如何确定树高呢？

   + 不难证明，树高**最低**是$log(n+1)$，也就是每个节点的左右两棵子树，所包含节点数量都差不多。

   + 树高最高是$n$，即退化成链表

   + 这就意味着，我们每次选择基准值的是和，都要尽可能选择处在待排序数组中间的数字，只有这样，快排才能到达最好的时间复杂度$O(nlogn)$



## 3.2空间复杂度

1. 快排使用递归，递归使用栈，所以空间复杂度也和**树高**有关
2. 且每次只使用了常数的空间，因此空间复杂度在$O(logn)$ ~ $O(n)$之间



这种分析方法的收获：

**数据结构的价值，在于其思维逻辑结构层面的价值**－－胡光



# 4.代码实现

```c++
int partition(int *arr, int l, int r) {
    //if (arr == nullptr || left < 0) return ;
    int temp = arr[l];//基准值
    while (l < r) {
        while (l < r && arr[r] >= temp) r--;
        if (l < r) arr[l++] = arr[r];
        while (l < r && arr[l] <= temp) l++;
        if (l < r) arr[r--] = arr[l];
    }
    arr[l] = temp;
    return l;
}

void quick_sort(int *arr, int l, int r) {
    if (arr == nullptr || l < 0) return ;
    if (r <= l) return ;//能不能写成 r == l ？ 这里可以写！因为50、51行的if避免了r<l的情况！

    int ind = partition(arr, l, r);
    if (ind > l) quick_sort(arr, l, ind - 1);
    if (ind < r) quick_sort(arr, ind + 1, r);
    return ;
}
```

