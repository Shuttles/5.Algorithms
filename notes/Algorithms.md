# 1.DP

## 1.1递推

要想理解DP，首先要理解***<u>递推</u>***。

***<u>递推是一种用若干步可重复的简单运算来描述复杂问题的方法</u>***。递推的特点在于，==每一项都和他前面的若干项有一定关联==。可以通过前面的若干项得出此项的数据。这种关系一般可以通过***<u>递推关系式来</u>***表示。

对于递推问题的求解一般从初始的一个或若干个数据项出发，通过递推关系式逐步推进，从而得出想要的结果，这种求解问题的方法叫递推法。

其中，初始的若干数据项称为边界。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                



### 例题(来自计蒜客)

#### 小兔兔问题

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gdq7ujqz66j31kw0u0aid.jpg)

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gdq7v8jjx6j31o40bmju0.jpg)



#### 信封问题

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gdq7w44sqjj31ri09ktbp.jpg)

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gdq7wk129gj31qy0qcqbp.jpg)

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gdq7wy1yz4j31qq0d6acy.jpg)



#### 二维递推

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gdq7za97yqj31rm0taai9.jpg)

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gdq81qrrbij31qs0sogu0.jpg)

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gdq8c4hau8j31qi0t6n65.jpg)



还有经典的马踏过河卒、杨辉三角、环形墙壁涂色问题，见计蒜客！(代码见此目录)



### 递推总结(hug)

思路

1. 定义状态(语义信息)，==这是最重要的！！状态不同方程就不同！==(菜鸟凭套路，高手凭直觉)

2. 确定递推方程

3. 程序实现

   + 正向递推

     即方程咋写的就咋实现，一般用递归 + 记忆化实现

   + 逆向递推

     for循环(要给出边界)



#### 递归程序套路

1. 给递归程序一个明确的语义信息
2. 设定边界条件
3. 设计递归过程和处理过程
4. 设计返回值

## 1.2dp入门

### 历史

动态规划是编程解题的一种重要手段。

1951年美国数学家`R.Bellman`等人，根据一类多阶段问题的特点，把多阶段决策问题转化为一系列==相互联系==的单阶段问题，然后逐个加以解决。

与此同时，他提出了解决这类问题的”最优化原理“，从而创建了解决最优化问题的一种新方法：动态规划！



### 基本概念

1. 阶段(==说实话不太懂阶段和状态的区别==)
   + 把所给问题的求解过程恰当地分成若干个相互联系的阶段，以便于求解。
   + 过程不同，阶段数就可能不同。
   + 描述阶段的变量称为阶段变量常用k表示。
   + 阶段的划分，一般是根据时间和空间的自然特征来划分，但要便于把问题的过程转化为多阶段决策的过程。
2. 状态
   + 状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。
   + 通常一个阶段有若干个状态，状态通常可以用一个或一组数来描述，称为状态变量。
3. 决策
   + 表示当过程处于某一阶段的某个状态时，可以做出不同的决定，从而确定下一阶段的状态，这种决定称为决策。
   + 不同的决策对应着不同的数值，描述决策的变量称为决策变量。
4. ==状态转移方程==
   + dp中本阶段的状态往往是上一阶段的状态和上一阶段的决策的结果，由第i个阶段的状态f(i)和决策u(i)来确定第i+1个阶段的状态。
   + 状态转移表示为F(i + 1) = T(f(i), u(i))，称为状态转移方程。
5. 策略
   + 各个阶段决策确定后，整个问题的决策序列就构成了一个策略。
   + 对于每个实际问题，可供选择的策略有一定范围，称为允许策略集合。允许策略集合中达到最优效果的策略称为最优策略。



### 必须满足的条件

dp必须满足最优化原理与无后效性。

1. 最优化原理

   ”一个过程的最优决策具有这样的性质：即无论其初始状态和初始决策如何，其今后各个策略对第一个决策所形成的的状态作为初始状态的过程而言，必须构成最优策略“

   (==没看懂。。。==)

   也就是说一个最优策略的子策略，也是最优的。

2. 无后效性

   如果某阶段状态给定后，则在这个阶段以后过程的发展不受这个阶段以前各个状态的影响。



### 一个小例子

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gdtmmfy5pvj31er0u07f1.jpg)

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gdtmnz1rzzj31r00pgdlx.jpg)



### dp总结(hug)

1. dp问题是运筹学的一部分，也是***<u>递推问题的子集</u>***(特例)。

   区别在于：递推问题重在求解一个答案，而dp问题想要的是***<u>最优解</u>***

2. ==求解思路和递推相似==

3. 思路如下

   + 定义状态

   + 写出状态转移方程顺便划分阶段(==比如数字三角形中的一层==)

   + 检查是否有无后效性

     ==这个阶段的所有状态求解完成了之后就是完成了，不会被修改！==

   + 程序实现

4. 性质

   + 当前解可以由上一个阶段的解推出，由此，可以把问题简化成一个更小的子问题，而子问题具有相同的求解方式，只不过规模更小了而已。



### 经典引例--钱币问题

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gdtp54sdbsj31n40rg1kx.jpg)



1. ***<u>定义状态</u>***

   + 最简单的能想到的就是f(n)，表示拼凑n便士的方法总数

   + 但是这个状态会和前面的状态产生怎样的关系呢？

     是说不清楚的，***<u>因为还有一个最重要的量，你没有在状态f(n)中表现出来！----多少种钱币</u>***

   + 若考虑到多少种钱币，那么就可定义出新的状态

     ***<u>f(k, n)--用前k种钱币拼凑出n便士的方法总数</u>***

     (前k种，并不意味着前k种钱币一定都要用上！)

   + 由这个状态可以得到，f(k - 1, n)是f(k, n)的一个子集

2. ***<u>确定状态转移方程以及顺便划分阶段</u>***

   `f(k, n) = f(k - 1, n) + f(k, n - w(k))`

   其中，前者表示*<u>**一定没用到第k种钱币的方法总数**</u>*，后者表示***<u>一定用到了第k中钱币的方法总数(w(k)表示第k种钱币的面值)</u>***，两者没有交集！

3. ***<u>检查有无后效性</u>***

   确实有

4. ***<u>程序实现</u>***

==边界条件==：`f(1, n) = 1     f(k, 0) = 1 ` ==值得深入思考！==

==即用前1种钱币拼凑n元的方法总数只有1种，用前k种硬币拼凑0元的方法总数也只有1种！==

+ 正向递推

  递归+ 记忆化

+ 逆向递推

  for循环

  > 代码实现请去Project-Euler-19-7目录里找第31题！
  >
  > 里面包括了
  >
  > + 正向递推
  >
  > + 逆向递推及其优化(二维数组转一维)
  >
  >   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gdur518wk9j31d60r6k4k.jpg)
  >
  >   






### 经典引例--数字三角形

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ge0fa5w72kj31wg0u01i6.jpg)

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ge0fa9960aj31au0u04qp.jpg)

1. ***<u>定义状态</u>***

   `f(i, j)`为从顶向下，到坐标为(i, j)的点时的最大total， 这样最终我们要的最优解就是在数组f的最后一层找一个最大值！

   ==当然也可反向定义，自底向上！== 即从(i, j)这一点到最底端的最大total是多少， 这样f(0, 0)就是我们要的最优解！！

2. ***<u>确定状态转移方程顺便划分阶段</u>***

   前一种状态定义：`f(i, j) = max(f(i - 1, j), f(i - 1, j - 1)) + num[i, j]`

   后一种状态定义：`f(i, j) = max(f(i + 1, j), f(i + 1, j + 1)) + num[i, j]`

3. ***<u>检查是否有无后效性</u>***

   确实有

4. ***<u>程序实现</u>***

   > 去目录`20.Project-Euler-19-7里找！(18题)`







## 1.3经典例题

### 背包问题

#### 0/1背包

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ge2q16f2qqj31g20u04c4.jpg)

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1ge2q19dlyvj31a40qoq59.jpg)

==0/1背包的0、1就代表不选这件物品/选这件物品！==

1. ***<u>状态定义</u>***

   + 由题意可知，要求最大价值，那么最大价值一定是我们定义出来的状态的值！

   + 那么这个状态有几个维度呢？

     这就要看==究竟有哪些量可以影响最大价值！==

     经过分析可知，物品的件数(种类)、背包的最大承重会影响最大价值

   + 所以，`dp[i][j] 代表有i种物品可选、背包最大承重为j时的最大价值`

2. ***<u>状态转移方程的确定以及顺便划分阶段</u>***

   `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])`

   + 其中，`dp[i - 1][j]`代表一定不选第i件物品！
   + `dp[i - 1][j - v[i]] + w[i]`代表一定选第i件物品！

3. ***<u>检查有无后效性</u>***

   确实有

4. ***<u>程序实现</u>***

   去该目录下找背包问题看代码！

   + 第一版，用二维数组`dp[MAX_N + 5][MAX_V + 5]`

   + 第二版，用滚动数组`dp[2][MAX_V + 5]`，可以循环使用！

     可以这么做的前提是我们定义的状态只跟上一维的状态有关！

   + 第三版，只用一维数组`dp[MAX_V + 5]`！

     注意，此时跟新要从后面往前更新，因为计算`dp[i][j]`时要用到==前面的==`dp[i - 1][j - v[i]]`

     仔细想想为什么钱币问题中不用从后面往前更新！

   

   

   

   #### 完全背包

   ![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ge2qmdg8h6j311b0u017n.jpg)

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ge2qmhelo3j30r60v0wgo.jpg)

   ==这道题就是在0/1背包上改的！只不过每件物品可以选无数次！==

   1. ***<u>状态定义</u>***

      和0/1背包一样！

   2. ***<u>状态转移方程的确定及划分阶段</u>***

      `dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]) `

      与0/1背包唯一不同的只有max()中的后者！因为每种物品有无限件！

   3. ***<u>检查有无后效性</u>***

      确实有

   4. ***<u>程序实现</u>***

      与0/1背包基本相同！唯一不同的就是可以==从前往后==跟新！(如果用一维数组的话)

   



#### 多重背包

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1ge2qv50ahbj31hj0u0wwm.jpg)

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ge2qvazk4uj31800u0dje.jpg)

==这题就是介于01背包和完全背包之间的！所以解题思路很类似！==

1. ***<u>状态定义</u>***

   和01背包相同！

2. ***<u>状态转移方程的确定和划分阶段</u>***

   也和01背包相同！而不是和完全背包相同！

3. **<u>*检查是否有无后效性*</u>**

   确实有

4. ***<u>程序实现</u>***

   + 第一版(硬生生转为多重01背包)

     按照跑多次0/1背包的方式去实现！也就是多加一层循环，每种物品有几个，就循环几次！(==还是从后往前更新！==)

   + 第二版(二进制拆分法)

     + 前一版是把m件某种物品划分成m次1件该物品来分组，但是这样太慢了！

     + 我们找到了一种更好的分组方法，也就是二进制拆分！

       比如说14件某种物品分为==1 2 4 7(而不是8)==，这样就拆分成了4组而不是14组！

     + 为什么可以这么分组呢？

       因为每种结果确实一一对应选了那几组！

       比如说，最优方案中这种物品选6个，那就是选中了2 4 那一组，如果选7个那就是 7或者1 2 4。

     + ==总的来说，就是二进制拆分法可以去遍历当前这个物品选择1件到m件的若干种情况！==

     + ==与0/1背包对比，多重背包就是对分成的这些组的每个组选或者不选！==

   + 第三版(单调队列)

     + 可以将时间复杂度降到O(nv) 和0/1背包相同！这是最快的！



#### 启示

1. 一定要理解清楚代码的实现过程！(==for循环是一层一层来实现的==)(这对理解最长公共子序列1很有用！)









### 子序列问题

#### 最长公共子序列1

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ge2xk4324gj322x0u0n4g.jpg)

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1ge2xk7s5qsj30u00uamzn.jpg)



1. ***<u>状态定义</u>***

   + 首先求的是最长公共子序列，所以dp数组中的值就是最长公共子序列长度

   + 接着思考维度，最长的公共子序列跟什么因素有关？

     那肯定是==字符串截止到哪一位==

     + 我一开始想的是两个字符串的指针==同时移动==，所以定义的`dp[i]`是两个字符串截止到第i位，最长公共子序列的长度。

       状态转移方程为`dp[i] = dp[i - 1]; if (a[i] == b[i]) dp[i] += 1;`

       写出来程序跑了一下发现大错特错。。

     + 根据错误发现，两个指针==不应该是同时移动==，所以又定义了`dp[i][j]`为，string a截止到第i位，string b截止到第j位，两个字符串的最长公共子序列长度。

       状态转移方程为`dp[i][j] = dp[i - 1][j - 1]; if(a[i] == b[i]) dp[i][j] += 1;`

       写出来程序一跑，发现也错的。。

       实在没招了，就看的答案(计蒜客)

     + 计蒜客正解：

       这道题的复杂之处在于同时处理两个数组，我们用`dp[i][j]`表示数组a截止到下标i，数组b截止到下标j的最长公共子序列长度。(==状态定义和我后来想的是一样的==)

2. ***<u>状态转移方程的确定及阶段的划分</u>***

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ge2yevkzj8j30q207eaao.jpg)

3. ***<u>检查是否有无后效性</u>***

   确实有

4. ***<u>程序实现</u>***

5. ***<u>过程演示</u>***

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ge2yeyryq4j31qk0nidjm.jpg)

   

   

   

## 1.4DP的优化

分为三个方面

1. 状态定义的优化
   + 比如墙壁涂色
2. 状态转移的优化
   + 最长上升子序列的优化
3. 程序优化
   + 比如背包问题的优化

