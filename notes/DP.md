# 1.递推

要想理解DP，首先要理解***<u>递推</u>***。

***<u>递推是一种用若干步可重复的简单运算来描述复杂问题的方法</u>***。递推的特点在于，==每一项都和他前面的若干项有一定关联==。可以通过前面的若干项得出此项的数据。这种关系一般可以通过***<u>递推关系式来</u>***表示。

对于递推问题的求解一般从初始的一个或若干个数据项出发，通过递推关系式逐步推进，从而得出想要的结果，这种求解问题的方法叫递推法。

其中，初始的若干数据项称为边界。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                



## 1.1例题(来自计蒜客)

### 小兔兔问题

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gdq7ujqz66j31kw0u0aid.jpg)

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gdq7v8jjx6j31o40bmju0.jpg)



### 信封问题

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gdq7w44sqjj31ri09ktbp.jpg)

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gdq7wk129gj31qy0qcqbp.jpg)

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gdq7wy1yz4j31qq0d6acy.jpg)



### 二维递推

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gdq7za97yqj31rm0taai9.jpg)

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gdq81qrrbij31qs0sogu0.jpg)

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gdq8c4hau8j31qi0t6n65.jpg)



还有经典的马踏过河卒、杨辉三角、环形墙壁涂色问题，见计蒜客！(代码见此目录)



## 1.2递推总结(hug)

思路

1. 定义状态(语义信息)，==这是最重要的！！状态不同方程就不同！==(菜鸟凭套路，高手凭直觉)

2. 确定递推方程

3. 程序实现

   + 正向递推

     即方程咋写的就咋实现，一般用递归 + 记忆化实现

   + 逆向递推

     for循环(要给出边界)



## 1.3递归程序套路

1. 给递归程序一个明确的语义信息
2. 设定边界条件
3. 设计递归过程和处理过程
4. 设计返回值

# 2.dp入门

## 2.1历史

动态规划是编程解题的一种重要手段。

1951年美国数学家`R.Bellman`等人，根据一类多阶段问题的特点，把多阶段决策问题转化为一系列==相互联系==的单阶段问题，然后逐个加以解决。

与此同时，他提出了解决这类问题的”==最优化原理==“，从而创建了解决最优化问题的一种新方法：动态规划！



## 2.2基本概念

1. 阶段(==说实话不太懂阶段和状态的区别==)
   + 把所给问题的求解过程恰当地分成若干个相互联系的阶段，以便于求解。
   + 过程不同，阶段数就可能不同。
   + 描述阶段的变量称为阶段变量常用k表示。
   + 阶段的划分，一般是根据时间和空间的自然特征来划分，但要便于把问题的过程转化为多阶段决策的过程。
2. 状态
   + 状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。
   + 通常一个阶段有若干个状态，状态通常可以用一个或一组数来描述，称为状态变量。
3. 决策
   + 表示当过程处于某一阶段的某个状态时，可以做出不同的决定，从而确定下一阶段的状态，这种决定称为决策。
   + 不同的决策对应着不同的数值，描述决策的变量称为决策变量。
4. ==状态转移方程==
   + dp中本阶段的状态往往是上一阶段的状态和上一阶段的决策的结果，由第i个阶段的状态f(i)和决策u(i)来确定第i+1个阶段的状态。
   + 状态转移表示为F(i + 1) = T(f(i), u(i))，称为状态转移方程。
5. 策略
   + 各个阶段决策确定后，整个问题的决策序列就构成了一个策略。
   + 对于每个实际问题，可供选择的策略有一定范围，称为允许策略集合。允许策略集合中达到最优效果的策略称为最优策略。



## 2.3必须满足的条件

dp必须满足最优化原理与无后效性。

1. 最优化原理

   ”一个过程的最优决策具有这样的性质：即无论其初始状态和初始决策如何，其今后各个策略对第一个决策所形成的的状态作为初始状态的过程而言，必须构成最优策略“

   (==没看懂。。。==)

   也就是说一个最优策略的子策略，也是最优的。

2. 无后效性

   如果某阶段状态给定后，则在这个阶段以后过程的发展不受这个阶段以前各个状态的影响。



## 2.4一个小例子

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gdtmmfy5pvj31er0u07f1.jpg)

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gdtmnz1rzzj31r00pgdlx.jpg)



## 2.5dp总结(hug)

1. dp问题是运筹学的一部分，也是***<u>递推问题的子集</u>***(特例)。

   区别在于：递推问题重在求解一个答案，而dp问题想要的是***<u>最优解</u>***

2. ==求解思路和递推相似==

3. 思路如下

   + 定义状态

   + 写出状态转移方程顺便划分阶段(==比如数字三角形中的一层==)

   + 检查是否有无后效性

     ==这个阶段的所有状态求解完成了之后就是完成了，不会被修改！==

   + 程序实现

4. 性质

   + 当前解可以由上一个阶段的解推出，由此，可以把问题简化成一个更小的子问题，而子问题具有相同的求解方式，只不过规模更小了而已。



## 2.6经典引例--钱币问题

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gdtp54sdbsj31n40rg1kx.jpg)



1. ***<u>定义状态</u>***

   + 最简单的能想到的就是f(n)，表示拼凑n便士的方法总数

   + 但是这个状态会和前面的状态产生怎样的关系呢？

     是说不清楚的，***<u>因为还有一个最重要的量，你没有在状态f(n)中表现出来！----多少种钱币</u>***

   + 若考虑到多少种钱币，那么就可定义出新的状态

     ***<u>f(k, n)--用前k种钱币拼凑出n便士的方法总数</u>***

     (前k种，并不意味着前k种钱币一定都要用上！)

   + 由这个状态可以得到，f(k - 1, n)是f(k, n)的一个子集

2. ***<u>确定状态转移方程以及顺便划分阶段</u>***

   `f(k, n) = f(k - 1, n) + f(k, n - w(k))`

   其中，前者表示*<u>**一定没用到第k种钱币的方法总数**</u>*，后者表示***<u>一定用到了第k种钱币的方法总数(w(k)表示第k种钱币的面值)</u>***，两者没有交集！

3. ***<u>检查有无后效性</u>***

   确实有

4. ***<u>程序实现</u>***

==边界条件==：`f(1, n) = 1     f(k, 0) = 1 ` ==值得深入思考！==

==即用前1种钱币拼凑n元的方法总数只有1种，用前k种硬币拼凑0元的方法总数也只有1种！==

可以这么思考，什么情况下会用到`f(k, 0)`？只有一种情况，就是比如==算`f(2, 2)`时==，用到第二种钱币时。这么一想，`f(k, 0)`确实必须为1！！

+ 正向递推

  递归+ 记忆化

+ 逆向递推

  for循环

  > 代码实现请去Project-Euler-19-7目录里找第31题！
  >
  > 里面包括了
  >
  > + 正向递推
  >
  > + 逆向递推及其优化(二维数组转一维)
  >
  >   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gdur518wk9j31d60r6k4k.jpg)
  >
  >   






## 2.7经典引例--数字三角形

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ge0fa5w72kj31wg0u01i6.jpg)

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ge0fa9960aj31au0u04qp.jpg)

1. ***<u>定义状态</u>***

   `f(i, j)`为从顶向下，到坐标为(i, j)的点时的最大total， 这样最终我们要的最优解就是在数组f的最后一层找一个最大值！

   ==当然也可反向定义，自底向上！== 即从(i, j)这一点到最底端的最大total是多少， 这样f(0, 0)就是我们要的最优解！！

2. ***<u>确定状态转移方程顺便划分阶段</u>***

   前一种状态定义：`f(i, j) = max(f(i - 1, j), f(i - 1, j - 1)) + num[i, j]`

   后一种状态定义：`f(i, j) = max(f(i + 1, j), f(i + 1, j + 1)) + num[i, j]`

3. ***<u>检查是否有无后效性</u>***

   确实有

4. ***<u>程序实现</u>***

   > 去目录`20.Project-Euler-19-7里找！(18题)`







# 3.经典例题

## 3.1背包问题

### 0/1背包

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ge2q16f2qqj31g20u04c4.jpg)

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1ge2q19dlyvj31a40qoq59.jpg)

==0/1背包的0、1就代表不选这件物品/选这件物品！==

1. ***<u>状态定义</u>***

   + 由题意可知，要求最大价值，那么最大价值一定是我们定义出来的状态的值！

   + 那么这个状态有几个维度呢？

     这就要看==究竟有哪些量可以影响最大价值！==

     经过分析可知，物品的件数(种类)、背包的最大承重会影响最大价值

   + 所以，`dp[i][j] 代表有i种物品可选、背包最大承重为j时的最大价值`

2. ***<u>状态转移方程的确定以及顺便划分阶段</u>***

   `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])`

   + 其中，`dp[i - 1][j]`代表一定不选第i件物品！
   + `dp[i - 1][j - v[i]] + w[i]`代表一定选第i件物品！

3. ***<u>检查有无后效性</u>***

   确实有

4. ***<u>程序实现</u>***

   去该目录下找背包问题看代码！

   + 第一版，用二维数组`dp[MAX_N + 5][MAX_V + 5]`

   + 第二版，用滚动数组`dp[2][MAX_V + 5]`，可以循环使用！

     可以这么做的前提是我们定义的状态只跟上一维的状态有关！

   + 第三版，只用一维数组`dp[MAX_V + 5]`！

     注意，此时跟新要从后面往前更新，因为计算`dp[i][j]`时要用到==前面的==`dp[i - 1][j - v[i]]`

     仔细想想为什么钱币问题中不用从后面往前更新！

   

   

   

   ### 完全背包

   ![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1ge2qmdg8h6j311b0u017n.jpg)

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ge2qmhelo3j30r60v0wgo.jpg)

   ==这道题就是在0/1背包上改的！只不过每件物品可以选无数次！==

   1. ***<u>状态定义</u>***

      和0/1背包一样！

   2. ***<u>状态转移方程的确定及划分阶段</u>***

      `dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]) `

      与0/1背包唯一不同的只有max()中的后者！因为每种物品有无限件！

   3. ***<u>检查有无后效性</u>***

      确实有

   4. ***<u>程序实现</u>***

      与0/1背包基本相同！唯一不同的就是可以==从前往后==跟新！(如果用一维数组的话)

   



### 多重背包

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1ge2qv50ahbj31hj0u0wwm.jpg)

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ge2qvazk4uj31800u0dje.jpg)

==这题就是介于01背包和完全背包之间的！所以解题思路很类似！==

1. ***<u>状态定义</u>***

   和01背包相同！

2. ***<u>状态转移方程的确定和划分阶段</u>***

   也和01背包相同！而不是和完全背包相同！

3. **<u>*检查是否有无后效性*</u>**

   确实有

4. ***<u>程序实现</u>***

   + 第一版(硬生生转为多重01背包)

     按照跑多次0/1背包的方式去实现！也就是多加一层循环，每种物品有几个，就循环几次！(==还是从后往前更新！==)

   + 第二版(二进制拆分法)

     + 前一版是把m件某种物品划分成m次1件该物品来分组，但是这样太慢了！

     + 我们找到了一种更好的分组方法，也就是二进制拆分！

       比如说14件某种物品分为==1 2 4 7(而不是8)==，这样就拆分成了4组而不是14组！

     + 为什么可以这么分组呢？

       因为每种结果确实一一对应选了那几组！

       比如说，最优方案中这种物品选6个，那就是选中了2 4 那一组，如果选7个那就是 7或者1 2 4。

     + ==总的来说，就是二进制拆分法可以去遍历当前这个物品选择1件到m件的若干种情况！==

     + ==与0/1背包对比，多重背包就是对分成的这些组的每个组选或者不选！==

   + 第三版(单调队列)

     + 可以将时间复杂度降到O(nv) 和0/1背包相同！这是最快的！



### 启示

1. 一定要理解清楚代码的实现过程！(==for循环是一层一层来实现的==)(这对理解最长公共子序列1很有用！)









## 3.2子序列问题

### 最长公共子序列1

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ge2xk4324gj322x0u0n4g.jpg)

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1ge2xk7s5qsj30u00uamzn.jpg)



1. ***<u>状态定义</u>***

   + 首先求的是最长公共子序列，所以dp数组中的值就是最长公共子序列长度

   + 接着思考维度，最长的公共子序列跟什么因素有关？

     那肯定是==字符串截止到哪一位==

     + 我一开始想的是两个字符串的指针==同时移动==，所以定义的`dp[i]`是两个字符串截止到第i位，最长公共子序列的长度。

       状态转移方程为`dp[i] = dp[i - 1]; if (a[i] == b[i]) dp[i] += 1;`

       写出来程序跑了一下发现大错特错。。

     + 根据错误发现，两个指针==不应该是同时移动==，所以又定义了`dp[i][j]`为，string a截止到第i位，string b截止到第j位，两个字符串的最长公共子序列长度。

       状态转移方程为`dp[i][j] = dp[i - 1][j - 1]; if(a[i] == b[i]) dp[i][j] += 1;`

       写出来程序一跑，发现也错的。。

       实在没招了，就看的答案(计蒜客)

     + 计蒜客正解：

       这道题的复杂之处在于同时处理两个数组，我们用`dp[i][j]`表示数组a截止到下标i，数组b截止到下标j的最长公共子序列长度。(==状态定义和我后来想的是一样的==)

2. ***<u>状态转移方程的确定及阶段的划分</u>***

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ge2yevkzj8j30q207eaao.jpg)

3. ***<u>检查是否有无后效性</u>***

   确实有

4. ***<u>程序实现</u>***

5. ***<u>过程演示</u>***

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1ge2yeyryq4j31qk0nidjm.jpg)

   

   

   

# 4.DP的优化

分为三个方面

1. 状态定义的优化
   + 比如墙壁涂色
2. 状态转移的优化
   + 最长上升子序列的优化
3. 程序优化
   + 比如背包问题的优化













# ==以下是胡船长讲课内容的笔记==



# 1.从递推到动归



兔子繁殖问题

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gmimquhdp9j30mw0e3gus.jpg)

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gmimqrla11j30t70aewji.jpg)



![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gmimw95mxej30iw0gmgqa.jpg)



1. 重点是==递推状态！！==

2. 什么是状态定义？

   状态定义就是一个==数学符号+ 语义信息==(对于这个数学符号的描述)

3. 确定递推状态

   + 因变量和哪几个参数有关系，那么这几个参数就作为自变量，维数就是几维！
+ 本质就是寻找问题中的==自变量和因变量==！
  
4. 递推公式如何推导？

   + 通常情况下采用==容斥原理==

     比如小兔子这题

     ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gminfq4330j30jd0650vz.jpg)
     
   + 本质：分析状态中的容斥关系

   + 注意：

     推导过程中先是推导出f(n) = 第n个月成年兔子数量 + 第n个月幼年兔子数量，然后发现f(n-1)恰好等于前者，f(n-2)恰好等于后者。

5. 程序实现

   + 正向递推-- 递归+记忆化
   + 逆向递推--循环

 

## 1.1例题

### 1.1.1爬楼梯

### 1.1.2钱币问题

http://oj.haizeix.com/problem/42

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gmkoz8bwf4j310x0keap7.jpg)

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gmkoxbj6i3j31d20t51kx.jpg)

### 1.1.3墙壁涂色

比较难顶









# 2.动态规划

## 2.1引例--数字三角形

题面：

http://oj.haizeix.com/problem/43

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gmlai7l0m0j30zx0hrn7b.jpg)

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gmlalvwezvj30yy0o9dtr.jpg)



![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gmlan4psckj310z0n015c.jpg)

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gmlap8vc9rj31460qotpp.jpg)

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gmlaqmo2p7j314c0eyk0x.jpg)

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gmlarww0kzj315j0psx09.jpg)









## 2.2解题套路

1. 确定<u>动归状态</u>

2. 推导<u>状态转移方程</u>，理解：转移、决策

   + 所谓转移，把所有决定f(i,j)最优值的状态，放入到决策过程中

   + ==推导方向==

     + 我(dp[i])从哪里来

       + 用别的node值更新我的值

       + 例如：大部分题

     + 我(dp[i])到哪里去

       + 用我这个node的值更新其他值
       + 例如：杂务(P1113) 神经网络(P1038) 旅行计划(P1137)

   + “我从哪里来”的==分类==依据

     + ==**最后一个“不同”的点**==

       背包、lcs、最长公共子序列、摘花生(acwing1015)

       ![img](https://wx1.sinaimg.cn/mw690/005LasY6ly1gpgv2pu8anj30vh0hqwkk.jpg)

       ![img](https://wx1.sinaimg.cn/mw690/005LasY6ly1gpgu9ohhdrj30vs0hk10a.jpg)

3. 正确性证明：

   利用数学归纳法

4. 程序实现



## 2.3拓扑序

1. 拓扑序来源于图形结构，而图形结构是最最抽象的数据结构，必须理解成思维逻辑结构。

2. 拓扑序是一种图形结构上的依赖顺序，一个图的拓扑序不唯一。
3. ==定义==：合法的拓扑序就是一种排序，其中各node的依赖项必须出现在node前面
4. ==本质==作用：把图形结构变成一个一维序列；
   + 因为图形结构不能用循环遍历，一维序列可以



![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gmlaz0df4nj310v0qctpr.jpg)

A：起床

B：穿上衣 D：传外套

C：穿秋裤 E：穿外裤

F：下床



如何应用于dp？

结论：==dp中状态之间的求解顺序需要满足拓扑序==















# 3.经典题

## 3.1最长上升子序列

题面：

http://oj.haizeix.com/problem/44

1. 状态定义

   $f(i)$ 代表以$num[i]$ 结尾的最长上升子序列的长度

2. 状态转移方程

   其实就是==把$num[i]$ 接到能接的最长的子序列后面去==

   $f(i) = max(f[j]) + 1 |  j<i, num[j]<num[i]$

   ![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gml0x5f2i3j30z30icqgq.jpg)

3. 程序实现

4. 复杂度分析

   + 时间复杂度

     $O(n^2)$

5. 优化：

   对状态转移过程进行优化




PS:

1. 状态定义为什么不定义成

   $dp[i]$ 取前i位的字符串中，最长上升子序列的长度    呢？

   如果这么定义了，那么状态转移方程很难推导。既然是最长==上升==子序列，那肯定要是$num[i]$能接上去的，遍历找到能接上去的$num[j]$之后，如何知道接在哪个后面最长呢？你又没记录那个信息对吧？

   综上所述，定义$dp[i]$为==以$num[i]$为结尾的最长上升子序列的长度==，最为合适，这样最终ans就是遍历一遍$dp[i]$找出最大值就可以了。



## 3.2最长公共子序列

题面：

http://oj.haizeix.com/problem/45

1. 状态定义

   $dp[i][j]$ str1取前i位，str2取前j位，它们的最长公共子序列

2. 状态转移方程

   $$dp(i, j) = \left\{  \begin{aligned} &max[dp(i-1, j), dp(i, j-1)] &str1[i] \neq str2[j]\\  &dp(i - 1, j - 1)+1 &str1[i]= str2[j] \end{aligned} \right.$$

3. 程序实现

4. 复杂度分析

   + 时间复杂度

     $O(n * m)$

5. 学习重点

   注意到，==参与决策的状态数量，是会根据条件不同而改变的。==





## 3.3切割回文

题面

http://oj.haizeix.com/problem/46

1. 状态定义

   $dp[i]$ 以第i位为结尾，最少切几刀/分多少段

   PS：在这里以第i位为结尾和取前i位等价

   

2. 状态转移方程

   ![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gmlbkac5xqj30xq0hndv7.jpg)

   

3. 程序实现

4. 复杂度分析

   + 时间复杂度

     $O(n^2)$

5. 优化：

   + 因为效率差是发生在转移阶段，所以需要对转移阶段进行优化

6. 学习重点

   + 两种状态定义的比较(虽然是等价的)
     + 前者，特判特殊情况(切0刀)比较复杂
     + 后者，特判特殊情况较为简单
     + 所以后者更为优秀



## 3.4背包问题

### 3.4.1     0/1背包

题面：

http://oj.haizeix.com/problem/47

1. 状态定义

   $dp[i][j]$ 对前i个物品进行选择，背包容量为j时，可以获得的最大价值

2. 状态转移方程

   $$dp(i, j) = max \left\{  \begin{aligned} &dp(i-1, j) &没选第i件物品\\  &dp(i - 1, j - w[i])+v[i] &选了第i件物品 \end{aligned} \right.$$

3. 程序实现

   + 状态如何定义，程序就如何实现
   + 使用滚动数组，$dp[2][MAXV + 5]$
   + 直接降维成一维数组$dp[MAXV + 5]$

4. 复杂度分析

   + 时间复杂度

     $O(n * m)$

5. 学习重点

   + 优化

     注意状态定义并没有改变，只是程序实现进行了逻辑上的降维！



### 3.4.2 完全背包

题面：

http://oj.haizeix.com/problem/48

#### 朴素做法

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gnuyg3y9qej30u20c3jvq.jpg)

1. 状态定义

   $dp[i][j]$ 对前i个物品进行选择，背包容量为j时，可以获得的最大价值

2. 状态转移方程

   $dp[i][j] = max(dp[i - 1][j - k * v] + k * w)$  $k * v <= j$

3. 程序实现

   三层循环

4. 时间复杂度

   $O(n \times m^2)$



#### 优化做法

光哥的做法：

1. 状态定义

   $dp[i][j]$ 对前i个物品进行选择，背包容量为j时，可以获得的最大价值

2. 状态转移方程

   $$dp(i, j) = max \left\{  \begin{aligned} &dp(i-1, j) &没选第i件物品\\  &dp(i , j - w[i])+v[i] &选了若干件第i件物品 \end{aligned} \right.$$

   ps：

   + 第二种状态是保证选了第i件物品的，但是选多少件并不知道，也不需要知道。why？(看下面yxc的推导)

3. 程序实现

   直接在01背包的一维dp上修改即可
   
4. 时间复杂度

   $O(n \times m)$



yxc的推导：

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gnuyqghfc1j30ls08swg1.jpg)

1. 可以发现，并不需要知道每种物品选了多少件！
2. 于是可以优化掉最内层循环！



### 3.4.3 多重背包

题面：

http://oj.haizeix.com/problem/49

光哥做法：

问题模型转化：

1. 多重背包，每类物品多出了一个数量限制

2. 01背包，每种物品只有一个

3. 将多重背包中的数量限制，当做多个单一物品来处理。

4. 至此，就将多重背包问题转化成了01背包问题。

5. 时间复杂度

   $O(n \times m \times s)$

6. 这版程序只能得60分，还需优化！！



yxc做法

1. 和完全背包的yxc做法一样

2. 枚举件数ｋ，看看到底选几个该种物品，总价值为max

3. 时间复杂度

   $O(n \times m \times s)$

4. 考虑优化

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gnuziw3wdnj30pz0380tn.jpg)

   可见，$f[i, j-v]$　多出了一项，所以不能像完全背包那样优化！！





### 3.4.4分组背包

题面：

https://www.acwing.com/problem/content/9/

1. 其实思路和完全背包的朴素做法很相似

2. 方法：

   枚举第i组物品选哪个！(可以选0个)



## 3.5古老的打字机

题面：

http://oj.haizeix.com/problem/52

1. 状态定义

   $dp[i]$　打印前ｉ个字符的最小磨损值

2. 状态转移方程

   $dp[i] = min(dp[j] + (j+1到i的磨损值))$  $j < i$

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gnn3jfvz6pj30wa0hih0e.jpg)

3. 程序实现

   + $dp[i]$初始值一定要是$loss(1, i)$　代表了打字机只连续打印一次的情况！

4. 复杂度分析

   + 时间复杂度

     $O(n^2)$ --只能拿40分

5. 优化

   状态转移过程的优化－－==斜率优化==(非常优美！)

## 3.6扔鸡蛋

题面：

http://oj.haizeix.com/problem/50

1. 状态定义

   $dp[n][m]$ 用n个鸡蛋，测m层楼，最坏情况下最少测多少次

2. 状态转移方程

   $dp[n][m] = min(max\left\{\begin{aligned}&dp[n-1][k-1] + 1 &鸡蛋碎了\\&dp[n][m-k] + 1 &鸡蛋没碎\end{aligned})\right.$

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gmla3wibegj31h80luwuq.jpg)
   
   + max()   表示运气最差(最坏情况)
   + min()    表示最少测多少次
   
3. 程序实现

   1. 第一版：
      + 内存受限，开不了那么大数组（==和楼层数量强相关==）（由此可见还要优化），所以能开多少是多少（1000000）
      + 这题的边界情况需要注意！！$dp[1][m] = m$ ！！只有一个鸡蛋时只能从下往上测！！
      + 这版只能得30分，还需优化
      + 时间复杂度$O(n \times m^2)$
   2. 第二版：
      + 经过分析，如果想优化程序实现，最多只能去掉第一维，楼层数量还是无法去掉，所以只能优化==状态定义==
      + 看下面的优化





# 4. 动态规划的优化

## 4.1分类

1. 状态转移过程的优化
   + 不改变状态定义
   + 使用一些特殊的数据结构或者算法专门优化转移过程
2. 程序实现的优化
   + 例如01背包问题、钱币问题
   + 状态定义、转移过程也没变
3. 状态定义的优化（==最难做到的==）
   + 需要大量训练，才能培养出来的能力。
   + 从源头进行优化
4. 状态定义 -> 源头， 转移过程 -> 过程，程序实现 -> 结果



## 4.2扔鸡蛋

### 4.2.1转移过程的优化

![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gn8esszng8j30rn0gjdox.jpg)

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gn8eswtsakj30mx0ahgod.jpg)

![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gn8etzuujij30sl0f1thh.jpg)

1. 也就是说，通过寻找Ｋ与$dp[i - 1][k - 1]$和$dp[i][j - k]$的关系可以得到

   + 拐点，也就是最优的转移K值，一定发生在两者的交点处
   + 并且K是递增的

2. 知道了上述结论，就可以进行转移状态的优化了

   ![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gn8ewdmqodj30s70b5n3e.jpg)

3. 这样就可以不用做第三层循环来找ｋ了！直接顺着上一次的ｋ找就行了！

4. 优化后的时间复杂度为$O(n \times m)$ 





不明白的地方：

1. 为什么n不变的情况下，随m的增大，$dp[n][m]$ 也增大？
2. 为什么楼层超过一定范围之后，k值才会发生变化？比如对于100 和101层楼，k都是14
3. 为什么那两条直线一定会有交点？
   + 其实不需要一定有交点，如果没有交点，那就是最后一个点







### 4.2.2状态定义的优化

1. 原状态定义所需存储空间与m相关，m值域大，存不下

2. 当发现某个自变量与因变量之间存在==相关性==的时候，==两者即可对调==

3. $dp[n][m] = k$ 重定义为$dp[n][k] = m$ 表示n个鸡蛋扔k次，最多测多少层楼

4. k的值域小，当n=2时，$k \le \sqrt{2m} $ (？？不懂怎么来的， 所以程序实现中的$MAX_K$我也不知道怎么来的)

5. 状态转移方程

   + 其实这已经不能叫状态转移方程了，最多叫递推方程
   + 因为它没有决策过程

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gn8frqxkl9j30hi0ehgs5.jpg)

6. 打印出ｄｐ数组

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gn8g3kfixej30j70eodka.jpg)

7. 时间复杂度

   $O(n \times MAX_k)$
   
8. PS

   + 然而这种做法过不了leetcode！！！

     ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gn8yxbn9xbj316r0u0jws.jpg)

   + 原因：MAX_N太大了！导致后面有溢出！！

   + 解决方法：

     ==递归＋记忆化！！！！==





## 4.3多重背包

转移过程的优化

1. 本质上，我们想知道的是，对于某一类物品，具体要选择多少件，才是最优答案

2. 普通的单一拆分法，实际上==只是==想枚举某个物品选择1~s件的所有情况

3. 而二进制拆分法可以达到相同的效果，拆分出来的物品数量会更少！！

4. 拿14举例，普通拆分法14份，二进制拆分法4份物品

   ![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gnaetmhadhj30r40d0grd.jpg)

5. 有一点不懂，二进制拆分法是怎么想到的呢？它的==奥秘==是什么呢？

   + 光哥说，本质上每一堆就是位权！
   + 因为只有选/不选两种状态，所以只能是二进制！而不是什么三进制！

6. 改进后的时间复杂度

   $O(n \times m \times \sum_{i=1}^{i=n} {logs_i})$

7. 多重背包的**最优时间复杂度**其实是（使用单调队列）

   $O(n \times m)$



## 4.4最长上升子序列

状态转移过程的优化

1. 本质上，就是==找到符合条件的最大的长度值==，接在它后面即可

2. 于是，我们可以维护这样一个len数组，记录==每一种长度序列尾部最小值！==

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gnam1s7m06j30dv0grdke.jpg)

3. 状态转移方程就可以变为

   $dp[i]  = k + 1 | len[k]<num[i], k是最后一个满足这个条件的位置$

4. 而状态转移的过程就是找到最后一个满足这个条件的位置ｋ，而可以证明这个len[]是单调递增的(反证和数归都可以)，所以用二分就行

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gnamdkihhoj30xq0ibnbq.jpg)

5. 时间复杂度

   $O(n \times logn)$





## 4.5切割回文

状态转移过程的优化

1. 由于字符串是随机生成的，其中所能包含的回文串的数量是非常少的

2. 所以我们提前处理得到mark[]，$mark[i]$存储的是所有==以i位置作为结尾的回文串的起始坐标==

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gnaozyjq6gj30ih0ebn25.jpg)

3. 在转移过程中，利用$mark[]$,　就可以避免掉大量的无用循环遍历过程

4. 时间复杂度

   $O(n + m)$ m是字符串中回文串的数量





## 4.6古老的打字机

状态转移过程的优化--斜率优化

斜率优化推导过程

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gnn4gyeccqj30x50hktmn.jpg)

+ 目的：为了消去混合项！！

  ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gnn4mq8mv3j30xm0gbn97.jpg)

+ 结论1：如果k和j点的斜率< 2Si，那么就应该从ｊ点转移，而不是ｋ点！

  ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gnuynd213ej30x10i8aoa.jpg)

  ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gnn4xk7vl6j30ur0fz46g.jpg)

+ 结论2：备选答案中不会出现斜率呈弓字型的，斜率全部都是单调递增的！

+ 结论3：备选答案可以用单调递增队列(按斜率)来维护

  + 入队操作和往常相同
  + 过期出队操作其实就是==淘汰掉斜率<2Si的点==
  + 这样每次都从队首的那个点转移



总结

1. 时间复杂度

   $O(n)$

2. 说实话代码实现我不是很懂ＴＡＴ





# 5.练习题

## 5.1最大子段和

题面：

http://oj.haizeix.com/problem/606

https://www.acwing.com/problem/content/description/1481/

### 1.我的做法：

1. 状态定义

   $dp[i]$ 以第ｉ位作为结尾的最大子段和是多少

2. 状态转移方程

   我的做法

   + $$dp[i] =  \left\{  \begin{aligned} &dp[i - 1] + num[i] &dp[i - 1] >0\\  &num[i] &dp[i - 1]<=0 \end{aligned} \right.$$
   + 由于子段的==连续性==，很容易可以想到$dp[i]$所代表的子序列要么是接在前面的某个子序列后面，要么是自己一个。如何来分呢？看$dp[i - 1] >0$　就行了(==本质上就是看哪个大==)

3. 程序实现



### 2.yxc做法

1. 状态定义

   $dp[i]$　所有以第ｉ位作为右端点的子段区间中，和最大的是多少

2. 状态转移方程

   $dp[i] = max(num[i], dp[i - 1] + num[i])$

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gnwhqyjckjj30ky0eedit.jpg)

3. 程序实现

4. PS

   ==其实本质上和我的做法是一样的！！==





## 5.2波动数列

1. 其实本质上是组合问题！（背包问题）

2. 原序列所有的不同方案取决于什么呢？

   取决于每次d选啥以及x选啥(x可用其他表示)　即所有选法的总和

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6ly1gph2aekf6dj30zd0jbwko.jpg)

3. 闫氏DP

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6ly1gph2je589ij30w30i7dka.jpg)

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6ly1gph2iclelzj31110jiwkb.jpg)

4. 代码实现

   + 边界条件

     $f(0, 0) = 1,   f(0, i) = 0$  